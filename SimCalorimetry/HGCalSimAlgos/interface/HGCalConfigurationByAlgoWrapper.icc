#include "SimCalorimetry/HGCalSimAlgos/interface/HGCalConfigurationByAlgoWrapper.h"

//
template <typename C, typename D>
HGCalConfigurationByAlgoWrapper<C,D>::HGCalConfigurationByAlgoWrapper(){

  //q80fC
  encsParam_.push_back({636., 15.6, 0.0328});   //2nd order polynomial coefficients as function of capacitance
  chargeAtFullScaleADCPerGain_.push_back(80.);  //the num of fC (charge) which corresponds to the max ADC value
  preampPulses_.push_back({{0., 0., 1.0, 0.066 / 0.934, 0., 0.}});  //in-time bunch is the 3rd entry in the array

  //q160fC
  encsParam_.push_back({1045., 8.74, 0.0685});
  chargeAtFullScaleADCPerGain_.push_back(160.);
  preampPulses_.push_back({{0., 0., 1.0, 0.153 / 0.847, 0., 0.}});

  // q320fC
  encsParam_.push_back({1915., 2.79, 0.0878});
  chargeAtFullScaleADCPerGain_.push_back(320.);
  preampPulses_.push_back({{0., 0., 1.0, 0.0963 / 0.9037, 0., 0.}});

  // adc has 10 bits -> 1024 counts at max ( >0 baseline to be handled)
  for (auto fsc : chargeAtFullScaleADCPerGain_)
    lsbPerGain_.push_back(fsc / 1024.);
    
}

//
template <typename C, typename D>
void HGCalConfigurationByAlgoWrapper<C,D>::findFEConfigurationByAlgo(std::map<uint32_t, C> &conds) {
}


//
template <typename C, typename D>
hgcroc::HGCROCConfiguration HGCalConfigurationByAlgoWrapper<C,D>::getConfigurationForDetId(const D &detId) {
  hgcroc::HGCROCConfiguration conf;
  return conf;
}

//
template <typename C, typename D>
double HGCalConfigurationByAlgoWrapper<C,D>::getTOTOnset(hgcroc::HGCROCDynamicRange_t gainIdx,double vtol) {
  if (gainIdx==hgcroc::HGCROCDynamicRange_t::AUTO) return -1;
  return chargeAtFullScaleADCPerGain_[gainIdx] - vtol;
}

//
template <typename C, typename D>
double HGCalConfigurationByAlgoWrapper<C,D>::estimateENCs(hgcroc::HGCROCDynamicRange_t gainIdx,double cap) {
  return encsParam_[gainIdx][0] + encsParam_[gainIdx][1] * cap + encsParam_[gainIdx][2] * pow(cap, 2);
}

//
template <typename C, typename D>
double HGCalConfigurationByAlgoWrapper<C,D>::estimateOptimalENCp(double ileak) {
  if (ileak > 45.40)
    return 23.30 * ileak + 1410.04;
  else if (ileak > 38.95)
    return 30.07 * ileak + 1156.76;
  else if (ileak > 32.50)
    return 38.58 * ileak + 897.94;
  else if (ileak > 26.01)
    return 193.67 * pow(ileak, 0.70) + 21.12;
  else if (ileak > 19.59)
    return 167.60 * pow(ileak, 0.77);
  else if (ileak > 13.06)
    return 162.35 * pow(ileak, 0.82);
  else if (ileak > 6.53)
    return 202.73 * pow(ileak, 0.81);
  else
    return 457.15 * pow(ileak, 0.57);
}




//LEFT OVERS START HERE
//#include "SimCalorimetry/HGCalSimProducers/interface/HGCFEElectronics.h"
//#include "DataFormats/ForwardDetId/interface/HGCSiliconDetId.h"
//#include "DataFormats/ForwardDetId/interface/HFNoseDetId.h"
//#include "Geometry/HGCalGeometry/interface/HGCalGeometry.h"
//#include <string>
//#include <array>
//#include <unordered_map>
//
//
//
//
//  struct SiCellOpCharacteristics {
//    noise;
//        unsigned short gain, thrADC;
//    noise(0.), gain(0), thrADC(0) {}
//    SiCellOpCharacteristics() : lnfluence(0.), fluence(0.), ileak(0.), enc_s(0.), enc_p(0.), mipfC(0), mipADC(0) {}
//    SiCellOpCharacteristicsCore core;
//    double lnfluence, fluence, ileak, enc_s, enc_p, mipfC;
//    unsigned int mipADC;
//  };
//
//
//
//  double getENCpad(double ileak);
//  double getTDCOnsetAuto(uint32_t gainIdx);
//  
//  inline void setENCCommonNoiseSubScale(double val) { encCommonNoiseSub_ = val; }
//    GainRange_t defaultGain_;
//  int defaultAimMIPtoADC_;
//    //common noise subtraction noise (final scaling value)
//  double encCommonNoiseSub_;
//
//
//    bool  ignoreNoise_, ignoreGainDependentPulse_, activateCachedOp_;
//
////
//void HGCalSiConditionsByAlgo::setGeometry(const CaloSubdetectorGeometry *hgcGeom, GainRange_t gain, int aimMIPtoADC) {
//  //call base class method
//  HGCalRadiationMap::setGeometry(hgcGeom);
//
//  defaultGain_ = gain;
//  defaultAimMIPtoADC_ = aimMIPtoADC;
//
//  //exit if cache is to be ignored
//  if (!activateCachedOp_)
//    return;
//
//  //fill cache if it's not filled
//  if (!siopCache_.empty())
//    return;
//
//  const auto &validDetIds = geom()->getValidDetIds();
//  for (const auto &did : validDetIds) {
//    unsigned int rawId(did.rawId());
//    T hgcDetId(rawId);
//
//    //compute and store in cache
//    siopCache_.emplace(rawId, getSiCellOpCharacteristicsCore(hgcDetId));
//  }
//}
//

//      defaultAimMIPtoADC_(10),
//      encCommonNoiseSub_(sqrt(1.0)),
//      qe2fc_(1.60217646E-4),
//      ignoreNoise_(false),
//      ignoreGainDependentPulse_(false),
//      activateCachedOp_(false)
//
//  ignoreNoise_ = ((algo >> NOISE) & 0x1);
//  ignoreGainDependentPulse_ = ((algo >> PULSEPERGAIN) & 0x1);
//  activateCachedOp_ = ((algo >> CACHEDOP) & 0x1);
//
//
////
//
//
//                                                                                                       const T &cellId,
//                                                                                                    GainRange_t gain,
//                                                                                                    int aimMIPtoADC) {
//  //decode cell properties
//  int layer = cellId.layer();
//  unsigned int cellThick = cellId.type();
//
//  //location of the cell
//  int subdet = cellId.subdet();
//  const auto &xy(
//      ddd()->locateCell(cellId.layer(), cellId.waferU(), cellId.waferV(), cellId.cellU(), cellId.cellV(), true, true));
//  double radius = sqrt(std::pow(xy.first, 2) + std::pow(xy.second, 2));  //in cm
//
//
//  //determine the gain to apply accounting for cce
//  //algo:  start with the most favored = lowest gain possible (=highest range)
//  //       test for the other gains in the preferred order
//  //       the first to yield <=15 ADC counts is taken
//  //       this relies on the fact that these gains shift the mip peak by factors of 2
//  //       in the presence of more gains 15 should be updated accordingly
//  //note:  move computation to higher granularity level (ROC, trigger tower, once decided)
//  double S(siop.core.cce * mipEqfC);
//  if (gain == GainRange_t::AUTO) {
//    gain = GainRange_t::q320fC;
//    std::vector<GainRange_t> orderedGainChoice = {GainRange_t::q160fC, GainRange_t::q80fC};
//    for (const auto &igain : orderedGainChoice) {
//      double mipPeakADC(S / lsbPerGain_[igain]);
//      if (mipPeakADC > 16)
//        break;
//      gain = igain;
//    }
//  }
//
//  //fill in the parameters of the struct
//  siop.core.gain = gain;
//  siop.mipfC = S;
//  siop.mipADC = std::floor(S / lsbPerGain_[gain]);
//  siop.core.thrADC = std::floor(S / 2. / lsbPerGain_[gain]);
//
//  //build noise estimate
//  if (ignoreNoise_) {
//    siop.core.noise = 0.0;
//    siop.enc_s = 0.0;
//    siop.enc_p = 0.0;
//  } else {
//    siop.enc_s = encsParam_[gain][0] + encsParam_[gain][1] * cellCap + encsParam_[gain][2] * pow(cellCap, 2);
//    siop.enc_p = getENCpad(siop.ileak);
//    siop.core.noise = hypot(siop.enc_p * encCommonNoiseSub_, siop.enc_s) * qe2fc_;
//  }
//
//
////
//const HGCalSiConditionsByAlgo::SiCellOpCharacteristicsCore HGCalSiConditionsByAlgo::getSiCellOpCharacteristicsCore(
//    const T &cellId, GainRange_t gain, int aimMIPtoADC) {
//  //re-compute
//  if (!activateCachedOp_)
//    return getSiCellOpCharacteristics(cellId, gain, aimMIPtoADC).core;
//
//  uint32_t key = cellId.rawId();
//
//  return siopCache_[key];
//}
//
//          enum SiPMGainRange_t { GAIN_2, GAIN_4, AUTO, GAINRANGE_N };  //roc gain for 2mm2 and 4mm2
//
//    SiPMonTileCharacteristics() : s(0.), lySF(0.), n(0.), xtalk(0), gain(0), thrADC(0), ntotalPE(0) {}
//    float s, lySF, n, xtalk;
//    unsigned short gain, thrADC, ntotalPE;
//  };
//
//  /**
//     @short returns the signal scaling and the noise
//  */
//  SiPMonTileCharacteristics scaleByDose(const HGCScintillatorDetId &,
//                                        const double,
//                                        const int aimMIPtoADC = 15,
//                                        const GainRange_t gainPreChoice = GainRange_t::AUTO);
//
//
//  void setSipmMap(const std::string &);
//  void setReferenceDarkCurrent(double idark);
//  void setReferenceCrossTalk(double xtalk) { refXtalk_ = xtalk; }
//  void setNpePerMIP(float npePerMIP);
//  std::array<double, GAINRANGE_N> getLSBPerGain() { return lsbPerGain_; }
//  std::array<double, GAINRANGE_N> getMaxADCPerGain() { return fscADCPerGain_; }
//  std::array<double, TILETYPE_N> getNpePerMIP() { return nPEperMIP_; }
//  float getNPeInSiPM() { return maxSiPMPE_; }
//  bool ignoreAutoPedestalSubtraction() { return ignoreAutoPedestalSub_; }
//
//  
//  /**
//     @short parses the radius boundaries for the SiPM area assignment from a custom file
//   */
//  std::unordered_map<int, float> readSipmPars(const std::string &);
//
//  
//  //lsb and fsc per gain
//  std::array<double, GAINRANGE_N> lsbPerGain_, fscADCPerGain_;
//
//  
//  //reference cross talk parameter (0,1) - if -1 it will be used to ignore effect in the digitization step
//  double refXtalk_;
//
//  //reference ADC counts for the MIP peak
//  int aimMIPtoADC_;
//
//  //sipm size boundaries
//  std::unordered_map<int, float> sipmMap_;
//      aimMIPtoADC_(15),
//
// //full scale charge per gain in nPE
//  //this is chosen for now such that the ref. MIP peak is at N ADC counts
//  //to be changed once the specs are fully defined such that the algorithm chooses the best gain
//  //for the MIP peak to be close to N ADC counts (similar to Si) or applying other specific criteria
//  fscADCPerGain_[GAIN_2] = nPEperMIP_[CAST] * 1024. / aimMIPtoADC_;      //2 mm^2  SiPM
//  fscADCPerGain_[GAIN_4] = 2 * nPEperMIP_[CAST] * 1024. / aimMIPtoADC_;  //4mm^2   SiPM
//
//  //lsb: adc has 10 bits -> 1024 counts at max
//  for (size_t i = 0; i < GAINRANGE_N; i++)
//    lsbPerGain_[i] = fscADCPerGain_[i] / 1024.f;
//}
//
////
//void HGCalSiPMonTileConditionsByAlgo::setSipmMap(const std::string& fullpath) { sipmMap_ = readSipmPars(fullpath); }
//
////
//std::unordered_map<int, float> HGCalSiPMonTileConditionsByAlgo::readSipmPars(const std::string& fullpath) {
//  std::unordered_map<int, float> result;
//  //no file means default sipm size
//  if (fullpath.empty())
//    return result;
//
//  edm::FileInPath fp(fullpath);
//  std::ifstream infile(fp.fullPath());
//  if (!infile.is_open()) {
//    throw cms::Exception("FileNotFound") << "Unable to open '" << fullpath << "'" << std::endl;
//  }
//  std::string line;
//  while (getline(infile, line)) {
//    int layer;
//    float boundary;
//
//    //space-separated
//    std::stringstream linestream(line);
//    linestream >> layer >> boundary;
//
//    result[layer] = boundary;
//  }
//  return result;
//}
//
//
//                                                                          int aimMIPtoADC,
//                                                                          GainRange_t gainPreChoice)
//  HGCalSiPMonTileConditionsByAlgo::GainRange_t gain = sipm.second;
//
//  sipmChar.thrADC = std::floor(0.5 * S / lsbPerGain_[gain]);
//    sipmChar.xtalk = refXtalk_;
//
////
//std::pair<double, HGCalSiPMonTileConditionsByAlgo::GainRange_t> HGCalSiPMonTileConditionsByAlgo::scaleBySipmArea(
//    const HGCScintillatorDetId& cellId, const double radius, const HGCalSiPMonTileConditionsByAlgo::GainRange_t& gainPreChoice) {
//  //start with the prechosen gain
//  //if auto then override it according to the SiPM area
//  HGCalSiPMonTileConditionsByAlgo::GainRange_t gain(gainPreChoice);
//  if (gainPreChoice == HGCalSiPMonTileConditionsByAlgo::GainRange_t::AUTO)
//    gain = GainRange_t::GAIN_2;
//
//  double scaleFactor(1.f);
//
//  if (ignoreSiPMarea_)
//    return std::pair<double, HGCalSiPMonTileConditionsByAlgo::GainRange_t>(scaleFactor, gain);
//
//  //use sipm area boundary map
//  if (overrideSiPMarea_) {
//    int layer = cellId.layer();
//    if (sipmMap_.count(layer) > 0 && radius < sipmMap_[layer]) {
//      scaleFactor = 2.f;
//      if (gainPreChoice == HGCalSiPMonTileConditionsByAlgo::GainRange_t::AUTO)
//        gain = GainRange_t::GAIN_4;
//    }
//  }
//  //read from DetId
//  else {
//    int sipm = cellId.sipm();
//    if (sipm == 0) {
//      scaleFactor = 2.f;
//      if (gainPreChoice == HGCalSiPMonTileConditionsByAlgo::GainRange_t::AUTO)
//        gain = GainRange_t::GAIN_4;
//    }
//  }
//
//  return std::pair<double, HGCalSiPMonTileConditionsByAlgo::GainRange_t>(scaleFactor, gain);
//}
//
